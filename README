Shadow (c) 2010-2012 Rob Jansen jansen@cs.umn.edu

A. Dependencies
---------------
Shadow requires the following:
    gcc
    make
    xz-utils
    Python 2.7
    CMake >= 2.8
    GLib >= 2.28.8

On Ubuntu, use something like:
$ sudo apt-get -y install gcc xz-utils python2.7 cmake libglib2.0 libglib2.0-dev     build-essential bin-utils 

On Fedora, use something like:
$ sudo yum install -y gcc xz python cmake glib2 glib2-devel

B. Setup
--------
The setup.py script will help you configure, build, and install Shadow. It has 
an extensive help menu which can be accessed with:
$ python setup.py --help

Shadow does not require root privileges, and the default and recommended setup
is to install to ~/.shadow as follows:
$ python setup.py build
$ python setup.py install

You may add ~/.shadow/bin to your PATH for convenience.

All build output is generated out-of-source, by default to the ./build directory.
The setup.py script is a wrapper to cmake and make. Using cmake and make directly
is also possible, but strongly discouraged. Installing shadow installs the
Shadow binary (shadow-bin) and an additional python wrapper script (shadow) that 
assists in running the Shadow binary. 

C. Running Shadow
-----------------
The Shadow wrapper script is used to handle some environmental variables that
need to get set before running shadow-bin. This is particularly useful if a
plug-in is using LD_PRELOAD to intercept certain function calls from its
user-space application, or for properly running Shadow under valgrind. To get
usage information for the wrapper script:
$ shadow --usage

The wrapper script forwards all unhandled arguments to shadow-bin, which handles
most of the configuration. For shadow-bin usage information:
$ shadow --help

Of potential interest are several built-in plug-ins which shadow-bin may run 
automatically. Use the following for help regarding the built-in plug-ins:
$ shadow --help-plug-ins

When developing and running Shadow plug-ins, one or more valid XML files 
describing the experiment must be provided. Examples of XML files can be found 
in the resource/ directory. To run an experiment using those files:
$ shadow resource/example.topology.xml resource/example.hosts.xml

Shadow also includes a pre-built topology file generated from real network
metrics gathered from large-scale planetlab experiments. This may be
decompressed using xz utils:
$ xz -d resource/topology.xml.xz

This may prevent the need to generate a synthetic topology and should make 
running experiments easier by only requiring changes to the hosts.xml file. An 
experiment using the included topology may then be run:
$ shadow resource/topology.xml resource/example.hosts.xml

D. Developer's Notes
--------------------
Documentation

Documentation may be generated by running doxygen:
$ doxygen Doxyfile

Then check the doc/ directory. Documentation is currently sparse, but planned
for future releases.

Topology File Format

The topology was generated from the PlanetLab experiments from the Shadow design
paper. The format is general enough to easily swap out specific measurements of 
latency, jitter, packetloss, etc, once we have a better data source without
changing the format. There are two main elements:

<cluster id="BGBG" bandwidthdown="22429" bandwidthup="11805"/>

For US and CA, the cluster ID is the two letter country code followed by
the two letter state/territory code. For other countries, the two letter
country code is given twice. This gives a unique ID for each cluster.
Bandwidth down and up is taken from netindex data.

<link id="link1" clusters="ARAR BGBG" latency="145" jitter="13"
packetloss="0.026"/>

Links are directed, connecting the given clusters. The link ID is
meaningless other than to provide uniqueness. Latency was computed as
the median of our measurements from inter-node planetlab pings between
the given clusters. Packetloss was taken from netindex data. Jitter was
computed as the average difference of the first and third quartiles from
the median, i.e.:

q1, latency, q3 = getQuartiles()
jitter = ((latency-q1) + (q3-latency)) / 2.0
if jitter >= latency: jitter = min(latency-q1, q3-latency)
assert jitter < latency

I believe this covers every country/state for which there is a code.

Debugging

To add extra debugging information and messages, add the -g flag when building
shadow. See the help menu with $ python setup.py --help.

To set LD_PRELOAD and run in gdb:
$ gdb shadow-bin
> set environment LD_PRELOAD=/home/ubuntu/.shadow/lib/libshadow-preload.so
> set args --echo
> run

If you want to be able to run Shadow through valgrind and the application you 
are running in Shadow uses OpenSSL, you should configure OpenSSL with the 
additional option: "-DPURIFY". This fixes OpenSSL so it doesn't break valgrind.
You may also want to ensure that debugging symbols are included in the GLib
that Shadow links to, and any library used by the plug-in. This can be achieved
with the compiler flag "-g".

System Limits

There is a default linux system limit on the number of open files. If each node 
in your Shadow plug-in opens many file descriptors (or if you have many nodes), 
you'll likely want to increase the limit so you application doesn't start 
getting errors when calling open().

See:
$ ulimit -n
$ cat /proc/sys/fs/file-*

Limits can be raised by modifying /etc/security/limits.conf and rebooting.
For example:
* soft nofile 10000
* hard nofile 10000
