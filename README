Shadow (c) 2011 Rob Jansen jansen@cs.umn.edu

======================
0. Quickstart (Install to ~/.local)
======================
(replace "rob" with your username)

$ wget http://www.openssl.org/source/openssl-1.0.0d.tar.gz
$ tar xvzf openssl-1.0.0d.tar.gz
$ cd openssl-1.0.0d
$ ./config --prefix=/home/rob/.local -fPIC shared
$ make
$ make install

$ wget http://monkey.org/~provos/libevent-2.0.11-stable.tar.gz
$ tar xvzf libevent-2.0.11-stable.tar.gz
$ cd libevent-2.0.11-stable
$ ./configure --prefix=/home/rob/.local CFLAGS="-fPIC -I/home/rob/.local" LDFLAGS="-L/home/rob/.local"
$ make
$ make install

X, Y, and Z are version numbers:
$ wget http://shadow.cs.umn.edu/downloads/shadow-vX.Y.Z.tar.gz
$ tar xvzf shadow-vX.Y.Z.tar.gz
$ cd shadow-vX.Y.Z
$ python setup.py auto

======================
I. Shadow dependencies
======================
The following are required to properly build and run Shadow:
  - gcc
  - cmake >= 2.6
  - flex
  - bison
  - openssl (installed manually)
  - libevent >= 2.0.10 (installed manually)
  
The following are optional, but HIGHLY recommended, for building and running Shadow:
  - python = 2.7.1

======================
II. Building Shadow
======================
The setup.py script has an extensive help menu ($ python setup.py --help)

The following will build and install to ~/.local (no root required)
Please make sure ~/.local/bin is in your PATH.
$ python setup.py auto

-or-

By default, the following will build and install to /usr/local (and so requires root)
$ python setup.py build
$ python setup.py install

All build output is generated out-of-source, by default to the ./build directory (although this 
location can be modified with the setup.py script). Both methods are
wrappers to cmake and make for building Shadow. Using cmake and make directly
is also possible, but strongly discouraged.

======================
III. Running Shadow
======================
There are multiple ways to run Shadow.

A. Using installed shadow script
--------------------------------
Installing shadow installs a script called "shadow", a wrapper to assist in running the
Shadow binary. The shadow script has several built-in plug-ins that can run automatically:

$ shadow autorun --help

to get usage and help regarding running the built-in plug-ins. Most of the options
can be left as default, and you need only specify which plug-in example
you want to run, e.g.

$ shadow autorun --echo-eth

When developing custom plug-ins, you may also run your plug-in with the shadow script
by using the 'run' command. Again, use

$ shadow run --help

for usage and help. When running a custom module, a dsim file describing the
experiment must be provided. Examples of dsim files can be found in mode 
src/plug-ins/* directories. Also see doc/ for the dsim API.

B. Running the shadow binary directly
-------------------------------------
You may also invoke the binary directly without the use of the
python script. Get usage information from Shadow with:

$ shadow-bin --help

The shadow binary also requires a dsim file. If possible, it is strongly recommended to
use the python script.

======================
IV. Developer's Notes:
======================

A. Debugging
------------
To add extra debugging information and messages, add the -g flag when building
shadow. See the help menu with $ python setup.py --help.

If you want to be able to run shadow through valgrind, you should configure 
openssl with the additional option: "-DPURIFY". This fixes openssl so it 
doesn't break valgrind, but will likely only cause problems if the application
you are running in shadow actually uses OpenSSL.

B. System Limits
----------------
There are some default system limits you'll want to be aware of. One is a limit
on the number of message queues and total bytes in them. Shadow will use a
message queue for each process, meaning it will use X=2 message queues by default,
and more if you try to run with multiple workers (not currently recommended). 

See: 
$ man mq_overview
$ ulimit -q
$ cat /proc/sys/fs/mqueue/queues_max

There is also a limit on the number of open files. If each node in your shadow
application opens many descriptors, you'll likely want to increase the limit so
you application doesn't start getting errors when calling open().

See:
$ ulimit -n
$ cat /proc/sys/fs/file-nr

Limits can be raised by modifying /etc/security/limits.conf and rebooting.
For example:
* soft msgqueue 8192000
* soft msgqueue 8192000
* soft nofile 10000
* hard nofile 10000
